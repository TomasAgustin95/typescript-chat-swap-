<!DOCTYPE html>
<html lang="en">
{%load static%}
<head>
  <title>Chat Swap</title>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="description" content="" />
  <link rel="stylesheet" type="text/css" href="{% static 'chatswap/NewStyle.css' %}" />
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
</head>
<body style="background-color: rgb(20,20,20);">
    <h1 class="title">Chatswap</h1>
    <button type="button" class="generalButton loginButton" id="login_button">Login</button>
    <div class="mainbox">
        <div class="swapbox">
            <button type="button" class="generalButton selectToken" id="sell_token">Select A Token</button>
            <input type="text" class="amountInput" placeholder="amount" id="sell_amount" onchange="getPrice('sell')">
          </div>
        <div class="swapbox">
            <button type="button" class="generalButton selectToken" id="buy_token">Select A Token</button>
            <input type="text" class="amountInput" placeholder="amount" id="buy_amount" onchange="getPrice('buy')">
        </div>
        <div class="gasText">
            <div>
            <p style="float:left; padding-left:15px; position: absolute;">Gas Estimate:</p>
            <p style="float:right; padding-right:15px; position absolute;" align="right" id = "gas_estimate">Test</p>
            </div>
            <button type="button" class="generalButton swapButton" id="swap_button">Swap</button>
        </div>
    </div>
  <div class="modal" tabindex="-1" role="dialog" id = "token_modal">
        <div class="modal-dialog" role="document">
            <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Tokens: </h5>
                <button type="button" id = "modal_close" class="generalButton close" data-dismiss="modal" aria-label="Close">
                <span aria-hidden="true">&times;</span>
                </button>
        </div>
            <div class="modalBody">
                {% for i in tokenData %}
                <div class="tokenRow" id = "token_{{i.ticker}}"> 
                {{i.ticker}} 
                </div>
                {% endfor %} 
            </div>
        </div>
    </div>

    
<script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.5/dist/umd/popper.min.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/js/bootstrap.min.js" crossorigin="anonymous"></script>
</body>
</html>
<script src="https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js"></script>
<script>
    console.log(window.ethereum);
    let accountPromise;
    let sellModalOpen = false;
    let buyModalOpen = false;
    let buytoken;
    let sellToken;
    let priceData;
    let buyAmount = false;
    let buyDecimals;
    let sellDecimals;
    let debug = false; //boolean to set any functions we want to use certain field values defined in the function for debugging
    
    function getAccount() {
        return ethereum.request({ method: 'eth_requestAccounts'});
    }
    
    document.getElementById("login_button").onclick = function(){
        accountPromise = getAccount().then(accounts => {
            console.log(accounts[0]);
            return accounts[0];
        })
    };
    
    console.log("{{tokenNames.0}}"); //testing template tags in js
    
    function getModal() {
      document.getElementById("token_modal").style.display = "block";
    }
    function closeModal() {
      document.getElementById("token_modal").style.display = "none";
    }
    document.getElementById("buy_token").onclick = function(){
      getModal()
      buyModalOpen = true;
      sellModalOpen = false;
      console.log("buy modal");
    };
    document.getElementById("sell_token").onclick = function(){
      getModal()
      sellModalOpen = true;
      buyModalOpen = false;
      console.log("sell modal");
      };
    document.getElementById("modal_close").onclick = function(){closeModal()};
    
    {% for i in tokenData %}
    document.getElementById("token_{{i.ticker}}").onclick = function() {
        if (buyModalOpen == true) {
            document.getElementById("buy_token").innerHTML = "{{i.ticker}}";
            buyToken = "{{ i.contract }}";
            buyDecimals = "{{ i.decimals }}";
            console.log(buyDecimals);
            console.log(buyToken);
            closeModal();
            //getPrice();
        }
        if (sellModalOpen == true) {
            document.getElementById("sell_token").innerHTML = "{{i.ticker}}";
            sellToken = "{{ i.contract }}";
            sellDecimals = "{{ i.decimals }}";
            console.log(sellDecimals);
            console.log(sellToken);
            closeModal();
            //getPrice();
        }
    }
    {% endfor %}
    function getPrice(buyOrSell) {
        if (buyToken != null && sellToken != null) {
            const Http = new XMLHttpRequest();
            let url= "https://api.0x.org/swap/v1/price/";
            if (debug) {
                url = "https://goerli.api.0x.org/swap/v1/price/"
            }
            const params = "buyToken=" + buyToken + "&sellToken=" + sellToken + "&" + buyOrSell;
            
                //console.log(Http.responseText["price"]);
                if (buyOrSell == "sell") {
                    amount = document.getElementById("sell_amount").value;
                    Http.open("GET", url + "?" + params + "Amount=" + amount * (10 ** (sellDecimals)));
                    Http.send();
                    Http.onreadystatechange = (e) => {
                        let responseDict = JSON.parse(Http.responseText);
                        document.getElementById("buy_amount").placeholder = null;
                        document.getElementById("buy_amount").value = (responseDict["price"] * amount).toFixed(buyDecimals);
                        document.getElementById("sell_amount").placeholder = "";
                    }
                }
                if (buyOrSell == "buy") {
                    amount = document.getElementById("buy_amount").value;
                    Http.open("GET", url + "?" + params + "Amount=" + amount * (10 ** (buyDecimals)));
                    Http.send();
                    Http.onreadystatechange = (e) => {
                        let responseDict = JSON.parse(Http.responseText);
                        document.getElementById("sell_amount").placeholder = null;
                        console.log(document.getElementById("sell_amount").value);
                        document.getElementById("sell_amount").value = (responseDict["price"] * amount).toFixed(sellDecimals);
                        document.getElementById("buy_amount").placeholder = "";
                    }
                }
        }
    }
    async function getQuote(approval) {
        if (buyToken != null && sellToken != null) {
            const account = await accountPromise;
            console.log(account); //testing getAccount()
            let responseDict;
            let amount;
            let params;
            //console.log(document.getElementById("sell_amount").value)
            amount = document.getElementById("sell_amount").value * (10 ** (sellDecimals));
            amount = Math.round(amount);
            console.log(amount);
            const Http = new XMLHttpRequest();
            let url= "https://api.0x.org/swap/v1/quote/";
            if (debug) {
                url= "https://goerli.api.0x.org/swap/v1/quote/";
            }
            if (approval) {
                params = "buyToken=" + buyToken + "&sellToken=" + sellToken + "&sellAmount=" +  amount + "&takerAddress=" + account + "&skipValidation=true"; 
            }
            else {
                params = "buyToken=" + buyToken + "&sellToken=" + sellToken + "&sellAmount=" +  amount + "&takerAddress=" + account // <-- Commented out to allow metamask to prompt user for a transaction (AKA avoiding error code 105 issue for testing beyond that issue).
            }
            console.log(sellDecimals);
            Http.open("GET", url + "?" + params);
            Http.send();
            return Http;
        }
    }
    
    function countDigits(number) {
        let s = number.toString();
        let count = 0;
        for (i = 0; i < s.length; i++) {
            if (s.charAt(i) != '.') {
                count++;
            }
            else {
                break;
            }
        }
        return count;
    } 
    
    document.getElementById("swap_button").onclick = function() { 
        accountPromise = getAccount().then(accounts => {
            return accounts[0];
        })
        swap();
    }
    
    async function swap() {
        const web3access = new Web3(window.ethereum)
        const abi = [{ "inputs": [ { "internalType": "string", "name": "name", "type": "string" }, { "internalType": "string", "name": "symbol", "type": "string" }, { "internalType": "uint256", "name": "max_supply", "type": "uint256" } ], "stateMutability": "nonpayable", "type": "constructor" }, { "anonymous": false, "inputs": [ { "indexed": true, "internalType": "address", "name": "owner", "type": "address" }, { "indexed": true, "internalType": "address", "name": "spender", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "value", "type": "uint256" } ], "name": "Approval", "type": "event" }, { "anonymous": false, "inputs": [ { "indexed": true, "internalType": "address", "name": "from", "type": "address" }, { "indexed": true, "internalType": "address", "name": "to", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "value", "type": "uint256" } ], "name": "Transfer", "type": "event" }, { "inputs": [ { "internalType": "address", "name": "owner", "type": "address" }, { "internalType": "address", "name": "spender", "type": "address" } ], "name": "allowance", "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "spender", "type": "address" }, { "internalType": "uint256", "name": "amount", "type": "uint256" } ], "name": "approve", "outputs": [ { "internalType": "bool", "name": "", "type": "bool" } ], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "account", "type": "address" } ], "name": "balanceOf", "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "uint256", "name": "amount", "type": "uint256" } ], "name": "burn", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "account", "type": "address" }, { "internalType": "uint256", "name": "amount", "type": "uint256" } ], "name": "burnFrom", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "decimals", "outputs": [ { "internalType": "uint8", "name": "", "type": "uint8" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "spender", "type": "address" }, { "internalType": "uint256", "name": "subtractedValue", "type": "uint256" } ], "name": "decreaseAllowance", "outputs": [ { "internalType": "bool", "name": "", "type": "bool" } ], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "spender", "type": "address" }, { "internalType": "uint256", "name": "addedValue", "type": "uint256" } ], "name": "increaseAllowance", "outputs": [ { "internalType": "bool", "name": "", "type": "bool" } ], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "name", "outputs": [ { "internalType": "string", "name": "", "type": "string" } ], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "symbol", "outputs": [ { "internalType": "string", "name": "", "type": "string" } ], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "totalSupply", "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "recipient", "type": "address" }, { "internalType": "uint256", "name": "amount", "type": "uint256" } ], "name": "transfer", "outputs": [ { "internalType": "bool", "name": "", "type": "bool" } ], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "sender", "type": "address" }, { "internalType": "address", "name": "recipient", "type": "address" }, { "internalType": "uint256", "name": "amount", "type": "uint256" } ], "name": "transferFrom", "outputs": [ { "internalType": "bool", "name": "", "type": "bool" } ], "stateMutability": "nonpayable", "type": "function" }];
        const maxApproval = "10000000000000000000000000000000000" // approval amount that may only be used for debugging, need to do more research to see if there is a security issue for users by allowing an unlimited amount token approval 
        console.log(maxApproval);
        const contract = new web3access.eth.Contract(abi, sellToken);
        const account = await accountPromise;
        allowanceQuote = await getQuote(true);
        swapQuote = await getQuote(false);
        allowanceQuote.onreadystatechange = (e) => { //Maybe should check if user has already set approval for sellToken passed in above depending on whether or not I decide to have users set unlimited token allowances per token approval.
            let responseDict = JSON.parse(allowanceQuote.responseText)
            contract.methods.approve(responseDict["allowanceTarget"], maxApproval).send({from: account}).then(tx => { //Token approval method for 0x api contract address
            console.log(tx);
            });
        };
        swapQuote.onreadystatechange = (e) => { //Need this to run AFTER a response from the above approve method returns a successful transaction.
            let responseDict = JSON.parse(swapQuote.responseText)
            console.log(web3access.eth.sendTransaction(responseDict));
        }
    }
    
    function ensureNotation(number) {
        let s = "" // Will implement later, basically is a function that will ensure numbers are not represented in scientific notation.
    }
        //Also, for tokens with over 21 decimals, javascript is going to put the amount into scientific notation.
        //So I need to find a way to ensure those sell amounts are in decimal format only.
    
    
        //Have figured out how to set token approvals/allowances in the swap function, which fixes the issues of error code 105.
        //Basically just have to set the token approval PRIOR to calling the quote. I can do this by requesting the quote with 
        //the skipValidation parameter set to true in order to pull the allowanceTarget to then be used in the .approve() method 
        //for the contract object at which point I can then call the sendTransaction method
        //with the web3 object instantiated with the window.ethereum object injected by metamask. 
        //
        //Issues to solve: 1. Every transaction is duplicated when called to metamask. 2. Need to figure out how to implement swapping
        //from pure ethereum to a token. This means that I have to instantiate a the contract object with ethereum being the current
        //"sellToken" paramter which is just the contract address for the sellToken. The ethereum coin obviously doesn't have a contract
        //address, so there must be a different way to create that object.
    
    </script>