
<!DOCTYPE html>
<html lang="en">
{% load static %}
{% load zrxrequests %}
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <title>Swap Demo Tutorial</title>
    <script src="https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
    <link rel="stylesheet" href="{% static 'chatswap/style.css' %}">
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-light bg-light">
        <a class="navbar-brand" href="#">My DEX Aggregator</a>
        <ul class="navbar-nav ml-auto">
          <li class="nav-item">
            <button id="login_button" class="btn btn-outline-primary my-2 my-sm-0" type="submit">Sign in with MetaMask</button>
          </li>
      </nav>
      <div class ="container">
        <div class="row">
            <div class="col col-md-6 offset-md-3" id="window">
                <h4>Swap</h4>
                <div id="form">
                    <div class="swapbox">
                        <div class="swapbox_select token_select" id = "sell_token">
                            SELECT A TOKEN
                        </div>
                        <div class="swapbox_select">
                            <input class="number form-control" placeholder="amount" id = "sell_amount" onchange = "getPrice('sell')">
                        </div>
                    </div>
                    <div class="swapbox">
                        <div class="swapbox_select token_select" id = "buy_token">
                            SELECT A TOKEN
                        </div>
                         <div class="swapbox_select">
                            <input class="number form-control" placeholder="amount" id="buy_amount" onchange = "getPrice('buy')">
                        </div>
                    </div>  
                    <div class="gas_estimate_label">Estimated Gas: <span id="gas_estimate"></span></div>
                    <button class="btn btn-large btn-primary btn-block" id="swap_button">Swap</button>                
                </div>
            </div>
        </div>
    </div>
    <div class="modal" tabindex="-1" role="dialog" id = "token_modal">
        <div class="modal-dialog" role="document">
          <div class="modal-content">
            <div class="modal-header">
              <h5 class="modal-title">Tokens: </h5>
              <button type="button" id = "modal_close" class="close" data-dismiss="modal" aria-label="Close">
                <span aria-hidden="true">&times;</span>
              </button>
            </div>
            <div class="modal-body">
                {% for i in tokenData %}
                <div class="individ_token_select" id = "token_{{i.ticker}}"> 
                {{i.ticker}} 
                </div>
                {% endfor %} 
          </div>
        </div>
    </div>
</body>
</html>
{% comment %} {% load static %}
    <script src="{% static 'chatswap/index.js' %}" type="text/javascript"></script> {% endcomment %}
<script src='https://cdn.jsdelivr.net/npm/bignumber.js@9.1.0/bignumber.min.js'></script>
<script>
console.log(window.ethereum);
let accountPromise;
let sellModalOpen = false;
let buyModalOpen = false;
let buytoken;
let sellToken;
let priceData;
let buyAmount = false;
let buyDecimals;
let sellDecimals;
let debug = false; //boolean to set any functions we want to use certain field values defined in the function for debugging

function getAccount() {
    return ethereum.request({ method: 'eth_requestAccounts'});
}

document.getElementById("login_button").onclick = function(){
    accountPromise = getAccount().then(accounts => {
        return accounts[0];
    })
};

console.log("{{tokenNames.0}}"); //testing template tags in js

function getModal() {
  document.getElementById("token_modal").style.display = "block";
}
function closeModal() {
  document.getElementById("token_modal").style.display = "none";
}
document.getElementById("buy_token").onclick = function(){
  getModal()
  buyModalOpen = true;
  sellModalOpen = false;
  console.log("buy modal");
};
document.getElementById("sell_token").onclick = function(){
  getModal()
  sellModalOpen = true;
  buyModalOpen = false;
  console.log("sell modal");
  };
document.getElementById("modal_close").onclick = function(){closeModal()};

{% for i in tokenData %}
document.getElementById("token_{{i.ticker}}").onclick = function() {
    if (buyModalOpen == true) {
        document.getElementById("buy_token").innerHTML = "{{i.ticker}}";
        buyToken = "{{ i.contract }}";
        buyDecimals = "{{ i.decimals }}";
        console.log(buyDecimals);
        console.log(buyToken);
        closeModal();
        //getPrice();
    }
    if (sellModalOpen == true) {
        document.getElementById("sell_token").innerHTML = "{{i.ticker}}";
        sellToken = "{{ i.contract }}";
        sellDecimals = "{{ i.decimals }}";
        console.log(sellDecimals);
        console.log(sellToken);
        closeModal();
        //getPrice();
    }
}
{% endfor %}
function getPrice(buyOrSell) {
    if (buyToken != null && sellToken != null) {
        const Http = new XMLHttpRequest();
        let url= "https://api.0x.org/swap/v1/price/";
        if (debug) {
            url = "https://goerli.api.0x.org/swap/v1/price/"
        }
        const params = "buyToken=" + buyToken + "&sellToken=" + sellToken + "&" + buyOrSell;
        
            //console.log(Http.responseText["price"]);
            if (buyOrSell == "sell") {
                amount = document.getElementById("sell_amount").value;
                Http.open("GET", url + "?" + params + "Amount=" + amount * (10 ** (sellDecimals)));
                Http.send();
                Http.onreadystatechange = (e) => {
                    let responseDict = JSON.parse(Http.responseText);
                    document.getElementById("buy_amount").placeholder = null;
                    document.getElementById("buy_amount").value = (responseDict["price"] * amount).toFixed(buyDecimals);
                    document.getElementById("sell_amount").placeholder = "";
                }
            }
            if (buyOrSell == "buy") {
                amount = document.getElementById("buy_amount").value;
                Http.open("GET", url + "?" + params + "Amount=" + amount * (10 ** (buyDecimals)));
                Http.send();
                Http.onreadystatechange = (e) => {
                    let responseDict = JSON.parse(Http.responseText);
                    document.getElementById("sell_amount").placeholder = null;
                    console.log(document.getElementById("sell_amount").value);
                    document.getElementById("sell_amount").value = (responseDict["price"] * amount).toFixed(sellDecimals);
                    document.getElementById("buy_amount").placeholder = "";
                }
            }
    }
}
async function getQuote(approval) {
    if (buyToken != null && sellToken != null) {
        const account = await accountPromise;
        console.log(account); //testing getAccount()
        let responseDict;
        let amount;
        let params;
        //console.log(document.getElementById("sell_amount").value)
        amount = document.getElementById("sell_amount").value * (10 ** (sellDecimals));
        amount = Math.round(amount);
        console.log(amount);
        const Http = new XMLHttpRequest();
        let url= "https://api.0x.org/swap/v1/quote/";
        if (debug) {
            url= "https://goerli.api.0x.org/swap/v1/quote/";
        }
        if (approval) {
            params = "buyToken=" + buyToken + "&sellToken=" + sellToken + "&sellAmount=" +  amount + "&takerAddress=" + account + "&skipValidation=true"; 
        }
        else {
            params = "buyToken=" + buyToken + "&sellToken=" + sellToken + "&sellAmount=" +  amount + "&takerAddress=" + account // <-- Commented out to allow metamask to prompt user for a transaction (AKA avoiding error code 105 issue for testing beyond that issue).
        }
        console.log(sellDecimals);
        Http.open("GET", url + "?" + params);
        Http.send();
        return Http;
    }
}

function countDigits(number) {
    let s = number.toString();
    let count = 0;
    for (i = 0; i < s.length; i++) {
        if (s.charAt(i) != '.') {
            count++;
        }
        else {
            break;
        }
    }
    return count;
} 

document.getElementById("swap_button").onclick = function() { 
    accountPromise = getAccount().then(accounts => {
        return accounts[0];
    })
    swap();
}

async function swap() {
    const web3access = new Web3(window.ethereum)
    const abi = [{ "inputs": [ { "internalType": "string", "name": "name", "type": "string" }, { "internalType": "string", "name": "symbol", "type": "string" }, { "internalType": "uint256", "name": "max_supply", "type": "uint256" } ], "stateMutability": "nonpayable", "type": "constructor" }, { "anonymous": false, "inputs": [ { "indexed": true, "internalType": "address", "name": "owner", "type": "address" }, { "indexed": true, "internalType": "address", "name": "spender", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "value", "type": "uint256" } ], "name": "Approval", "type": "event" }, { "anonymous": false, "inputs": [ { "indexed": true, "internalType": "address", "name": "from", "type": "address" }, { "indexed": true, "internalType": "address", "name": "to", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "value", "type": "uint256" } ], "name": "Transfer", "type": "event" }, { "inputs": [ { "internalType": "address", "name": "owner", "type": "address" }, { "internalType": "address", "name": "spender", "type": "address" } ], "name": "allowance", "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "spender", "type": "address" }, { "internalType": "uint256", "name": "amount", "type": "uint256" } ], "name": "approve", "outputs": [ { "internalType": "bool", "name": "", "type": "bool" } ], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "account", "type": "address" } ], "name": "balanceOf", "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "uint256", "name": "amount", "type": "uint256" } ], "name": "burn", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "account", "type": "address" }, { "internalType": "uint256", "name": "amount", "type": "uint256" } ], "name": "burnFrom", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "decimals", "outputs": [ { "internalType": "uint8", "name": "", "type": "uint8" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "spender", "type": "address" }, { "internalType": "uint256", "name": "subtractedValue", "type": "uint256" } ], "name": "decreaseAllowance", "outputs": [ { "internalType": "bool", "name": "", "type": "bool" } ], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "spender", "type": "address" }, { "internalType": "uint256", "name": "addedValue", "type": "uint256" } ], "name": "increaseAllowance", "outputs": [ { "internalType": "bool", "name": "", "type": "bool" } ], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "name", "outputs": [ { "internalType": "string", "name": "", "type": "string" } ], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "symbol", "outputs": [ { "internalType": "string", "name": "", "type": "string" } ], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "totalSupply", "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "recipient", "type": "address" }, { "internalType": "uint256", "name": "amount", "type": "uint256" } ], "name": "transfer", "outputs": [ { "internalType": "bool", "name": "", "type": "bool" } ], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "sender", "type": "address" }, { "internalType": "address", "name": "recipient", "type": "address" }, { "internalType": "uint256", "name": "amount", "type": "uint256" } ], "name": "transferFrom", "outputs": [ { "internalType": "bool", "name": "", "type": "bool" } ], "stateMutability": "nonpayable", "type": "function" }];
    const maxApproval = "10000000000000000000000000000000000" // approval amount that may only be used for debugging, need to do more research to see if there is a security issue for users by allowing an unlimited amount token approval 
    console.log(maxApproval);
    const contract = new web3access.eth.Contract(abi, sellToken);
    const account = await accountPromise;
    allowanceQuote = await getQuote(true);
    swapQuote = await getQuote(false);
    allowanceQuote.onreadystatechange = (e) => { //Maybe should check if user has already set approval for sellToken passed in above depending on whether or not I decide to have users set unlimited token allowances per token approval.
        let responseDict = JSON.parse(allowanceQuote.responseText)
        contract.methods.approve(responseDict["allowanceTarget"], maxApproval).send({from: account}).then(tx => { //Token approval method for 0x api contract address
        console.log(tx);
        });
    };
    swapQuote.onreadystatechange = (e) => { //Need this to run AFTER a response from the above approve method returns a successful transaction.
        let responseDict = JSON.parse(swapQuote.responseText)
        console.log(web3access.eth.sendTransaction(responseDict));
    }
}

function ensureNotation(number) {
    let s = "" // Will implement later, basically is a function that will ensure numbers are not represented in scientific notation.
}
    //Also, for tokens with over 21 decimals, javascript is going to put the amount into scientific notation.
    //So I need to find a way to ensure those sell amounts are in decimal format only.


    //Have figured out how to set token approvals/allowances in the swap function, which fixes the issues of error code 105.
    //Basically just have to set the token approval PRIOR to calling the quote. I can do this by requesting the quote with 
    //the skipValidation parameter set to true in order to pull the allowanceTarget to then be used in the .approve() method 
    //for the contract object at which point I can then call the sendTransaction method
    //with the web3 object instantiated with the window.ethereum object injected by metamask. 
    //
    //Issues to solve: 1. Every transaction is duplicated when called to metamask. 2. Need to figure out how to implement swapping
    //from pure ethereum to a token. This means that I have to instantiate a the contract object with ethereum being the current
    //"sellToken" paramter which is just the contract address for the sellToken. The ethereum coin obviously doesn't have a contract
    //address, so there must be a different way to create that object.

</script>